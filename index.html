<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>아두카의 임장여지도</title>
    <style>
        /* 기본 레이아웃 및 폰트 설정 */
        html, body { 
            height: 100%; 
            margin: 0; 
            padding: 0; 
            font-family: 'Malgun Gothic', sans-serif; 
        }
        #container { display: flex; height: 100%; }
        #map { 
            flex-grow: 1; 
            height: 100%; 
            position: relative; /* 자식 요소의 위치 기준점 */
        }
        
        /* 사이드바 스타일 */
        #sidebar {
            width: 250px;
            flex-shrink: 0;
            background-color: #f8f9fa;
            border-right: 1px solid #dee2e6;
            overflow-y: auto;
        }
        #sidebar h2 {
            margin: 0;
            padding: 15px;
            font-size: 18px;
            background-color: #e9ecef;
            border-bottom: 1px solid #dee2e6;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        .layer-group h3 {
            padding: 10px 15px;
            margin: 0;
            font-size: 14px;
            background-color: #f1f3f5;
            border-bottom: 1px solid #dee2e6;
            cursor: pointer;
            position: relative;
            user-select: none;
        }
        .layer-group h3::after {
            content: '▶';
            position: absolute;
            right: 15px;
            font-size: 10px;
            transition: transform 0.2s;
        }
        .layer-group.open h3::after {
            transform: rotate(90deg);
        }
        .layer-list {
            list-style-type: none;
            margin: 0;
            padding: 0;
            display: none;
        }
        .layer-group.open .layer-list {
            display: block;
        }
        .layer-list li {
            padding: 12px 15px;
            cursor: pointer;
            border-bottom: 1px solid #e9ecef;
            transition: background-color 0.2s;
            font-size: 14px;
        }
        .layer-list li:hover, .layer-list li.active {
            background-color: #d0e3ff;
        }

        /* 카카오맵 팝업창 스타일 */
        .area { 
            position: absolute; background: #fff; border: 1px solid #888; border-radius: 3px; 
            font-size: 12px; top: -5px; left: 15px; padding: 4px 6px;
        }
        .info { 
            font-size: 12px; padding: 10px 12px; line-height: 1.5;
            max-width: 220px; word-wrap: break-word;
        }
        .info .title { font-size: 15px; font-weight: bold; margin-bottom: 5px; }
        .info .link { font-size: 14px; }
        .info a { color: #1a73e8; text-decoration: none; }
        .info a:hover { text-decoration: underline; }

        /* ▼▼▼ 지도 위 제목 및 저작권 문구 스타일 (PC) ▼▼▼ */
        #map-title {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            color: black;
            font-size: 20px;
            font-weight: bold;
            pointer-events: none; /* 제목 뒤로 지도 조작 가능하도록 설정 */
        }
        #copyright {
            position: absolute;
            bottom: 10px;
            right: 10px;
            z-index: 10;
            color: black;
            font-size: 14px;
            font-weight: bold;
            pointer-events: none;
        }

        /* 모바일 화면을 위한 반응형 스타일 */
        @media (max-width: 768px) {
            #container {
                flex-direction: column;
            }
            #sidebar {
                width: 100%;
                height: 40%;
                border-right: none;
                border-bottom: 1px solid #dee2e6;
                -webkit-mask-image: linear-gradient(to bottom, black calc(100% - 40px), transparent 100%);
                mask-image: linear-gradient(to bottom, black calc(100% - 40px), transparent 100%);
            }
            #map {
                height: 60%;
            }
            /* ▼▼▼ 모바일용 스타일 수정 ▼▼▼ */
            #map-title {
                display: none; /* PC용 지도 제목 숨기기 */
            }
            #copyright {
                right: 50%; /* 중앙 정렬 */
                transform: translateX(50%);
                font-size: 10px; /* 폰트 크기 변경 */
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="sidebar">
            <h2 id="sidebar-title">아두카의 임장여지도</h2>
        </div>
        <div id="map">
            <div id="map-title">아두카의 임장여지도</div>
            <div id="copyright">All rights reserved</div>
        </div>
    </div>

    <script type="text/javascript" src="//dapi.kakao.com/v2/maps/sdk.js?appkey=5bc8237fbd068b286a064706ed55a6dd&libraries=drawing&autoload=false"></script>
    <script>
        // --- ▼▼▼ 모바일 제목 수정을 위한 코드 추가 ▼▼▼ ---
        // 화면 크기에 따라 사이드바 제목을 동적으로 변경합니다.
        function adjustTitle() {
            const sidebarTitle = document.getElementById('sidebar-title');
            if (window.innerWidth <= 768) {
                sidebarTitle.textContent = '아두카의 임장여지도';
            } else {
                sidebarTitle.textContent = '지역 목록';
            }
        }
        // 페이지 로드 시 및 창 크기 변경 시 함수 실행
        window.addEventListener('load', adjustTitle);
        window.addEventListener('resize', adjustTitle);
        // --- ▲▲▲ 코드 추가 끝 --- ▲▲▲

        kakao.maps.load(async function() {
            var groupedAreas = {}; 
            
            var mapContainer = document.getElementById('map'); 
            var options = { 
                center: new kakao.maps.LatLng(37.523663, 127.000393),
                level: 7
            };

            var map = new kakao.maps.Map(mapContainer, options);
            var customOverlay = new kakao.maps.CustomOverlay({});
            var infowindow = new kakao.maps.InfoWindow({ removable: true });

            let selectedPolygon = null;
            let selectedListItem = null;

            async function loadKmlData() {
                const initialKmlUrl = 'https://raw.githubusercontent.com/aducanumab/kakaomap/refs/heads/main/map_data.kml';
                try {
                    const initialResponse = await fetch(initialKmlUrl);
                    if (!initialResponse.ok) throw new Error('초기 KML 로딩 실패');
                    const initialKmlText = await initialResponse.text();
                    const parser = new DOMParser();
                    const initialKmlDoc = parser.parseFromString(initialKmlText, "application/xml");
                    const kmlNs = 'http://www.opengis.net/kml/2.2';
                    const hrefElem = initialKmlDoc.getElementsByTagNameNS(kmlNs, 'href')[0];
                    if (!hrefElem) throw new Error('KML에서 NetworkLink href를 찾을 수 없습니다.');
                    const finalKmlUrl = hrefElem.textContent;
                    const finalResponse = await fetch(finalKmlUrl);
                    if (!finalResponse.ok) throw new Error('최종 KML 로딩 실패');
                    const finalKmlText = await finalResponse.text();
                    const finalKmlDoc = parser.parseFromString(finalKmlText, "application/xml");
                    
                    const folders = finalKmlDoc.getElementsByTagNameNS(kmlNs, 'Folder');
                    for (let i = 0; i < folders.length; i++) {
                        const folder = folders[i];
                        const layerName = folder.getElementsByTagNameNS(kmlNs, 'name')[0]?.textContent || '미분류';
                        groupedAreas[layerName] = [];

                        const placemarks = folder.getElementsByTagNameNS(kmlNs, 'Placemark');
                        for (let j = 0; j < placemarks.length; j++) {
                            const placemark = placemarks[j];
                            const name = placemark.getElementsByTagNameNS(kmlNs, 'name')[0]?.textContent || '';
                            const description = placemark.getElementsByTagNameNS(kmlNs, 'description')[0]?.textContent || '';
                            const coordinatesElem = placemark.getElementsByTagNameNS(kmlNs, 'coordinates')[0];
                            if (!coordinatesElem) continue;
                            const coordinatesStr = coordinatesElem.textContent.trim();
                            const path = coordinatesStr.split(/\s+/).map(coordStr => {
                                const [lng, lat] = coordStr.split(',');
                                if (!isNaN(parseFloat(lat)) && !isNaN(parseFloat(lng))) {
                                    return new kakao.maps.LatLng(lat, lng);
                                }
                            }).filter(p => p);

                            if (path.length > 0) {
                                groupedAreas[layerName].push({ name: name, path: path, description: description });
                            }
                        }
                    }
                } catch (error) {
                    console.error("KML 처리 중 오류 발생:", error);
                    alert("지도 데이터를 불러오는 데 실패했습니다.");
                }
            }
            
            function displayArea(area, map, customOverlay, infowindow, listContainer) {
                var polygon = new kakao.maps.Polygon({
                    map: map,
                    path: area.path,
                    strokeWeight: 3,
                    strokeColor: '#8f0d2b',
                    strokeOpacity: 0.8,
                    fillColor: '#fff',
                    fillOpacity: 0.7
                });

                const listItem = document.createElement('li');
                listItem.textContent = area.name;
                listContainer.appendChild(listItem);

                function selectItem() {
                    if (selectedPolygon) {
                        selectedPolygon.setOptions({ fillColor: '#fff' });
                        selectedListItem.classList.remove('active');
                    }
                    polygon.setOptions({ fillColor: '#09f' });
                    listItem.classList.add('active');
                    selectedPolygon = polygon;
                    selectedListItem = listItem;
                }

                kakao.maps.event.addListener(polygon, 'mouseover', function(mouseEvent) {
                    if (polygon !== selectedPolygon) {
                        polygon.setOptions({ fillColor: '#09f' });
                        listItem.classList.add('active');
                    }
                    customOverlay.setContent('<div class="area">' + area.name + '</div>');
                    customOverlay.setPosition(mouseEvent.latLng); 
                    customOverlay.setMap(map);
                });

                kakao.maps.event.addListener(polygon, 'mouseout', function() {
                    if (polygon !== selectedPolygon) {
                        polygon.setOptions({ fillColor: '#fff' });
                        listItem.classList.remove('active');
                    }
                    customOverlay.setMap(null);
                });

                kakao.maps.event.addListener(polygon, 'click', function(mouseEvent) {
                    selectItem();
                    displayInfoWindow(area, mouseEvent.latLng, infowindow, map);
                });

                listItem.addEventListener('mouseover', () => {
                    if (polygon !== selectedPolygon) {
                        polygon.setOptions({ fillColor: '#09f' });
                    }
                    customOverlay.setContent('<div class="area">' + area.name + '</div>');
                    customOverlay.setPosition(getPolygonCenter(area.path));
                    customOverlay.setMap(map);
                });

                listItem.addEventListener('mouseout', () => {
                    if (polygon !== selectedPolygon) {
                        polygon.setOptions({ fillColor: '#fff' });
                    }
                    customOverlay.setMap(null);
                });
                
                listItem.addEventListener('click', () => {
                    selectItem();
                    const bounds = new kakao.maps.LatLngBounds();
                    area.path.forEach(point => {
                        bounds.extend(point);
                    });
                    map.setBounds(bounds);
                    setTimeout(() => {
                        if (map.getLevel() > 5) {
                            map.setLevel(5);
                        }
                    }, 400);
                    displayInfoWindow(area, bounds.getCenter(), infowindow, map);
                });
            }
            
            function displayInfoWindow(area, position, infowindow, map) {
                const urlMatch = area.description.match(/https?:\/\/[^\s<]+/);
                let content = '<div class="info">' +
                              '   <div class="title">' + area.name + '</div>';
                if (urlMatch && urlMatch[0]) {
                    content += '   <div class="link"><a href="' + urlMatch[0] + '" target="_blank">임장기 보러가기</a></div>';
                }
                content += '</div>';
                infowindow.setContent(content);
                infowindow.setPosition(position);
                infowindow.setMap(map);
            }

            function getPolygonCenter(path) {
                const bounds = new kakao.maps.LatLngBounds();
                path.forEach(point => bounds.extend(point));
                return bounds.getCenter();
            }

            await loadKmlData();

            var listContainer = document.getElementById('polygon-list-container');
            
            for (const layerName in groupedAreas) {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'layer-group';
                const groupTitle = document.createElement('h3');
                groupTitle.textContent = layerName;
                groupDiv.appendChild(groupTitle);
                const groupList = document.createElement('ul');
                groupList.className = 'layer-list';
                groupDiv.appendChild(groupList);
                listContainer.appendChild(groupDiv);

                groupTitle.addEventListener('click', () => {
                    groupDiv.classList.toggle('open');
                });

                groupedAreas[layerName].forEach(area => {
                    displayArea(area, map, customOverlay, infowindow, groupList);
                });
            }
        });
    </script>
</body>
</html>
