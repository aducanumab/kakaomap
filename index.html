<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8"/>
	<title>Kakao Map - KML Polygon Overlay</title>
    <style>
        html, body, #map {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }
    </style>
</head>
<body>
    <div id="map"></div>

	<script type="text/javascript" src="//dapi.kakao.com/v2/maps/sdk.js?appkey=5bc8237fbd068b286a064706ed55a6dd&libraries=drawing&autoload=false"></script>
	<script>
		kakao.maps.load(function() {
            // 지도를 담을 영역의 DOM 레퍼런스
		    var mapContainer = document.getElementById('map'); 
            
            // 지도를 생성할 때 필요한 기본 옵션
		    var options = { 
			    center: new kakao.maps.LatLng(37.5665, 126.9780), //지도의 중심좌표. (예: 서울 시청)
			    level: 9 //지도의 레벨(확대, 축소 정도)
		    };

            // 지도 생성 및 객체 리턴
		    var map = new kakao.maps.Map(mapContainer, options); 

            // KML 파일을 불러와 처리하는 메인 함수를 호출합니다.
            loadAndProcessKml(map);
        });

        // KML 파일을 불러와 파싱하고 지도에 폴리곤을 그리는 비동기 함수
        async function loadAndProcessKml(map) {
            // 1. 첫 번째 KML 파일 (네트워크 링크만 있는 파일) 주소
            const initialKmlUrl = 'https://raw.githubusercontent.com/aducanumab/kakaomap/refs/heads/main/map_data.kml';

            try {
                // --- 1단계: '바로가기' KML 파일 로딩 및 URL 추출 ---
                const initialResponse = await fetch(initialKmlUrl);
                if (!initialResponse.ok) throw new Error('초기 KML 로딩 실패');
                const initialKmlText = await initialResponse.text();
                const parser = new DOMParser();
                const initialKmlDoc = parser.parseFromString(initialKmlText, "application/xml");
                const kmlNs = 'http://www.opengis.net/kml/2.2';
                const hrefElem = initialKmlDoc.getElementsByTagNameNS(kmlNs, 'href')[0];
                if (!hrefElem) throw new Error('KML에서 NetworkLink href를 찾을 수 없습니다.');
                const finalKmlUrl = hrefElem.textContent;

                // --- 2단계: 최종 KML 파일 로딩 ---
                const finalResponse = await fetch(finalKmlUrl);
                if (!finalResponse.ok) throw new Error('최종 KML 로딩 실패');
                const finalKmlText = await finalResponse.text();
                const finalKmlDoc = parser.parseFromString(finalKmlText, "application/xml");

                // --- 3단계: KML에 정의된 스타일 정보 파싱 ---
                const styles = {};
                const styleMaps = {};
                // StyleMap 파싱
                const styleMapElements = finalKmlDoc.getElementsByTagNameNS(kmlNs, 'StyleMap');
                for (let i = 0; i < styleMapElements.length; i++) {
                    const styleMap = styleMapElements[i];
                    const mapId = '#' + styleMap.getAttribute('id');
                    const pairs = styleMap.getElementsByTagNameNS(kmlNs, 'Pair');
                    for (let j = 0; j < pairs.length; j++) {
                        const key = pairs[j].getElementsByTagNameNS(kmlNs, 'key')[0]?.textContent;
                        const styleUrl = pairs[j].getElementsByTagNameNS(kmlNs, 'styleUrl')[0]?.textContent;
                        if (key === 'normal') styleMaps[mapId] = styleUrl;
                    }
                }
                // Style 파싱
                const styleElements = finalKmlDoc.getElementsByTagNameNS(kmlNs, 'Style');
                for (let i = 0; i < styleElements.length; i++) {
                    const style = styleElements[i];
                    const styleId = '#' + style.getAttribute('id');
                    styles[styleId] = {};
                    const lineStyle = style.getElementsByTagNameNS(kmlNs, 'LineStyle')[0];
                    const polyStyle = style.getElementsByTagNameNS(kmlNs, 'PolyStyle')[0];
                    if (lineStyle) {
                        const color = lineStyle.getElementsByTagNameNS(kmlNs, 'color')[0]?.textContent;
                        const width = lineStyle.getElementsByTagNameNS(kmlNs, 'width')[0]?.textContent;
                        if (color) {
                            const c = kmlColorToKakao(color);
                            styles[styleId].strokeColor = c.color;
                            styles[styleId].strokeOpacity = c.opacity;
                        }
                        if (width) styles[styleId].strokeWeight = parseFloat(width);
                    }
                    if (polyStyle) {
                        const color = polyStyle.getElementsByTagNameNS(kmlNs, 'color')[0]?.textContent;
                        if (color) {
                            const c = kmlColorToKakao(color);
                            styles[styleId].fillColor = c.color;
                            styles[styleId].fillOpacity = c.opacity;
                        }
                    }
                }

                // --- 4단계: Placemark를 순회하며 폴리곤 생성 ---
                const placemarks = finalKmlDoc.getElementsByTagNameNS(kmlNs, 'Placemark');
                for (let i = 0; i < placemarks.length; i++) {
                    const placemark = placemarks[i];
                    const styleUrl = placemark.getElementsByTagNameNS(kmlNs, 'styleUrl')[0]?.textContent || '';
                    const coordinatesElem = placemark.getElementsByTagNameNS(kmlNs, 'coordinates')[0];
                    if (!coordinatesElem) continue;

                    const coordinatesStr = coordinatesElem.textContent.trim();
                    const path = coordinatesStr.split(/\s+/).map(coordStr => {
                        const [lng, lat] = coordStr.split(',');
                        if (!isNaN(parseFloat(lat)) && !isNaN(parseFloat(lng))) {
                            return new kakao.maps.LatLng(lat, lng);
                        }
                    }).filter(p => p);

                    if (path.length === 0) continue;

                    // 폴리곤 옵션 설정 (기본값)
                    const polygonOptions = {
                        path: path,
                        strokeWeight: 2,
                        strokeColor: '#0000FF',
                        strokeOpacity: 0.8,
                        fillColor: '#0000FF',
                        fillOpacity: 0.3
                    };

                    // KML 스타일 적용
                    const finalStyleUrl = styleMaps[styleUrl] || styleUrl;
                    if (styles[finalStyleUrl]) {
                        Object.assign(polygonOptions, styles[finalStyleUrl]);
                    }

                    // 폴리곤 생성 및 지도에 표시
                    const polygon = new kakao.maps.Polygon(polygonOptions);
                    polygon.setMap(map);
                }
            } catch (error) {
                console.error("KML 처리 중 오류 발생:", error);
                alert("지도 데이터를 불러오는 데 실패했습니다.");
            }
        }

        // KML 색상(AABBGGRR)을 Kakao Map 스타일로 변환하는 함수
        function kmlColorToKakao(kmlColor) {
            const aabbggrr = kmlColor.padStart(8, '0');
            const alpha = parseInt(aabbggrr.substring(0, 2), 16) / 255.0;
            const blue = aabbggrr.substring(2, 4);
            const green = aabbggrr.substring(4, 6);
            const red = aabbggrr.substring(6, 8);
            return {
                color: `#${red}${green}${blue}`,
                opacity: alpha
            };
        }
	</script>
</body>
</html>
