<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Kakao Map with Grouped Polygon List</title>
    <style>
        /* 기본 레이아웃 */
        html, body { height: 100%; margin: 0; padding: 0; font-family: sans-serif; }
        #container { display: flex; height: 100%; }
        #map { flex-grow: 1; height: 100%; }
        
        /* 사이드바 스타일 */
        #sidebar {
            width: 250px;
            flex-shrink: 0;
            background-color: #f8f9fa;
            border-right: 1px solid #dee2e6;
            overflow-y: auto;
        }
        #sidebar h2 {
            margin: 0;
            padding: 15px;
            font-size: 18px;
            background-color: #e9ecef;
            border-bottom: 1px solid #dee2e6;
            position: sticky; /* 스크롤 시 상단에 고정 */
            top: 0;
        }
        .layer-group h3 {
            padding: 10px 15px;
            margin: 0;
            font-size: 14px;
            background-color: #f1f3f5;
            border-bottom: 1px solid #dee2e6;
        }
        #polygon-list, .layer-list {
            list-style-type: none;
            margin: 0;
            padding: 0;
        }
        .layer-list li {
            padding: 12px 15px;
            cursor: pointer;
            border-bottom: 1px solid #e9ecef;
            transition: background-color 0.2s;
            font-size: 14px;
        }
        .layer-list li:hover, .layer-list li.active {
            background-color: #d0e3ff;
        }

        /* 카카오맵 팝업창 스타일 */
        .area { position: absolute; background: #fff; border: 1px solid #888; border-radius: 3px; font-size: 12px; top: -5px; left: 15px; padding:2px; }
        .info .title { font-size: 15px; font-weight: bold; }
        .info .link { font-size: 14px; }
        .info a { color: #1a73e8; text-decoration: none; }
        .info a:hover { text-decoration: underline; }
    </style>
</head>
<body>
    <div id="container">
        <div id="sidebar">
            <h2>상권 목록</h2>
            <div id="polygon-list-container">
                <!-- KML 데이터가 그룹별로 이곳에 동적으로 추가됩니다. -->
            </div>
        </div>
        <div id="map"></div>
    </div>

    <script type="text/javascript" src="//dapi.kakao.com/v2/maps/sdk.js?appkey=5bc8237fbd068b286a064706ed55a6dd&libraries=drawing&autoload=false"></script>
    <script>
        // KML에서 파싱한 데이터를 레이어별로 그룹화하여 저장할 객체
        var groupedAreas = {}; 
        
        kakao.maps.load(async function() {
            var mapContainer = document.getElementById('map'); 
            var options = { 
                center: new kakao.maps.LatLng(37.523663, 127.000393), // 중심 좌표 수정
                level: 7 // 확대 레벨 수정
            };

            var map = new kakao.maps.Map(mapContainer, options);
            var customOverlay = new kakao.maps.CustomOverlay({});
            var infowindow = new kakao.maps.InfoWindow({ removable: true });

            await loadKmlData();

            var listContainer = document.getElementById('polygon-list-container');
            
            // 그룹화된 데이터를 순회하며 폴리곤과 목록을 생성합니다.
            for (const layerName in groupedAreas) {
                // 레이어 그룹 컨테이너 생성
                const groupDiv = document.createElement('div');
                groupDiv.className = 'layer-group';
                
                const groupTitle = document.createElement('h3');
                groupTitle.textContent = layerName;
                groupDiv.appendChild(groupTitle);

                const groupList = document.createElement('ul');
                groupList.className = 'layer-list';
                groupDiv.appendChild(groupList);
                
                listContainer.appendChild(groupDiv);

                // 해당 레이어의 폴리곤들을 순회합니다.
                groupedAreas[layerName].forEach(area => {
                    displayArea(area, map, customOverlay, infowindow, groupList);
                });
            }
        });

        async function loadKmlData() {
            const initialKmlUrl = 'https://raw.githubusercontent.com/aducanumab/kakaomap/refs/heads/main/map_data.kml';
            try {
                const initialResponse = await fetch(initialKmlUrl);
                if (!initialResponse.ok) throw new Error('초기 KML 로딩 실패');
                const initialKmlText = await initialResponse.text();
                const parser = new DOMParser();
                const initialKmlDoc = parser.parseFromString(initialKmlText, "application/xml");
                const kmlNs = 'http://www.opengis.net/kml/2.2';
                const hrefElem = initialKmlDoc.getElementsByTagNameNS(kmlNs, 'href')[0];
                if (!hrefElem) throw new Error('KML에서 NetworkLink href를 찾을 수 없습니다.');
                const finalKmlUrl = hrefElem.textContent;
                const finalResponse = await fetch(finalKmlUrl);
                if (!finalResponse.ok) throw new Error('최종 KML 로딩 실패');
                const finalKmlText = await finalResponse.text();
                const finalKmlDoc = parser.parseFromString(finalKmlText, "application/xml");
                
                // KML의 Folder(레이어)를 기준으로 파싱
                const folders = finalKmlDoc.getElementsByTagNameNS(kmlNs, 'Folder');
                for (let i = 0; i < folders.length; i++) {
                    const folder = folders[i];
                    const layerName = folder.getElementsByTagNameNS(kmlNs, 'name')[0]?.textContent || '미분류';
                    groupedAreas[layerName] = []; // 레이어별 배열 초기화

                    const placemarks = folder.getElementsByTagNameNS(kmlNs, 'Placemark');
                    for (let j = 0; j < placemarks.length; j++) {
                        const placemark = placemarks[j];
                        const name = placemark.getElementsByTagNameNS(kmlNs, 'name')[0]?.textContent || '';
                        const description = placemark.getElementsByTagNameNS(kmlNs, 'description')[0]?.textContent || '';
                        const coordinatesElem = placemark.getElementsByTagNameNS(kmlNs, 'coordinates')[0];
                        if (!coordinatesElem) continue;
                        const coordinatesStr = coordinatesElem.textContent.trim();
                        const path = coordinatesStr.split(/\s+/).map(coordStr => {
                            const [lng, lat] = coordStr.split(',');
                            if (!isNaN(parseFloat(lat)) && !isNaN(parseFloat(lng))) {
                                return new kakao.maps.LatLng(lat, lng);
                            }
                        }).filter(p => p);

                        if (path.length > 0) {
                            groupedAreas[layerName].push({ name: name, path: path, description: description });
                        }
                    }
                }
            } catch (error) {
                console.error("KML 처리 중 오류 발생:", error);
                alert("지도 데이터를 불러오는 데 실패했습니다.");
            }
        }
        
        function displayArea(area, map, customOverlay, infowindow, listContainer) {
            var polygon = new kakao.maps.Polygon({
                map: map,
                path: area.path,
                strokeWeight: 3, // 선 굵기 수정
                strokeColor: '#8f0d2b', // 선 색상 수정
                strokeOpacity: 0.8,
                fillColor: '#fff',
                fillOpacity: 0.7
            });

            const listItem = document.createElement('li');
            listItem.textContent = area.name;
            listContainer.appendChild(listItem);

            // 폴리곤 이벤트
            kakao.maps.event.addListener(polygon, 'mouseover', function(mouseEvent) {
                polygon.setOptions({ fillColor: '#09f' });
                listItem.classList.add('active');
                customOverlay.setContent('<div class="area">' + area.name + '</div>');
                customOverlay.setPosition(mouseEvent.latLng); 
                customOverlay.setMap(map);
            });
            kakao.maps.event.addListener(polygon, 'mouseout', function() {
                polygon.setOptions({ fillColor: '#fff' });
                listItem.classList.remove('active');
                customOverlay.setMap(null);
            });
            kakao.maps.event.addListener(polygon, 'click', function(mouseEvent) {
                displayInfoWindow(area, mouseEvent.latLng, infowindow, map);
            });

            // 목록 아이템(li) 이벤트
            listItem.addEventListener('mouseover', () => {
                polygon.setOptions({ fillColor: '#09f' });
                customOverlay.setContent('<div class="area">' + area.name + '</div>');
                customOverlay.setPosition(getPolygonCenter(area.path));
                customOverlay.setMap(map);
            });
            listItem.addEventListener('mouseout', () => {
                polygon.setOptions({ fillColor: '#fff' });
                customOverlay.setMap(null);
            });
            
            // --- ▼▼▼ 목록 아이템 클릭 이벤트 수정 ▼▼▼ ---
            listItem.addEventListener('click', () => {
                // 1. 폴리곤의 경계를 포함하는 LatLngBounds 객체를 생성합니다.
                const bounds = new kakao.maps.LatLngBounds();
                area.path.forEach(point => {
                    bounds.extend(point);
                });

                // 2. 지도에 생성한 경계를 설정합니다.
                // 이렇게 하면 지도의 중심과 확대 레벨이 자동으로 조정됩니다.
                map.setBounds(bounds);

                // 3. 잠시 후, 확대 레벨을 3으로 강제 설정합니다.
                // setBounds의 부드러운 이동 애니메이션이 끝날 시간을 벌어주기 위해
                // 약간의 딜레이(0.3초)를 줍니다.
                setTimeout(() => {
                    map.setLevel(3);
                }, 300);

                // 4. 정보창을 폴리곤의 중심에 표시합니다.
                displayInfoWindow(area, bounds.getCenter(), infowindow, map);
            });
            // --- ▲▲▲ 수정 끝 ▲▲▲ ---
        }
        
        function displayInfoWindow(area, position, infowindow, map) {
            const urlMatch = area.description.match(/https?:\/\/[^\s<]+/);
            let content = '<div class="info">' +
                          '   <div class="title">' + area.name + '</div>';
            if (urlMatch && urlMatch[0]) {
                content += '   <div class="link"><a href="' + urlMatch[0] + '" target="_blank">임장기 보러가기</a></div>';
            }
            content += '</div>';
            infowindow.setContent(content);
            infowindow.setPosition(position);
            infowindow.setMap(map);
        }

        function getPolygonCenter(path) {
            const bounds = new kakao.maps.LatLngBounds();
            path.forEach(point => bounds.extend(point));
            return bounds.getCenter();
        }
    </script>
</body>
</html>
